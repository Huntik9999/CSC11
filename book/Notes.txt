---------Notes--from--the--book----------------created--on--1/19/25------
CH.1 ~ Introduction
->talking about pi/intro
-------------------------------------------------------------------------
CH.2 ~ Starting Out
->fundementals of arm
-------------------------------------------------------------------------
CH.3 ~ First Time Out
->Command Line
    -words are case specific
    -dir = ls
->Creating a source file
    -source file = file.s
    -install packages with "sudo apt-get instal (package)"
    -make file with "text-editor file.s"
->Come to the Execution
    -create executable file:
        *$as -o file.o file.s 
            *as invokes the assebler program
            *-o creates a object file from the source file
        *$ld -o a.out file.o
            *ld links the files together

            *-o creates executable file from the object file
    -execute file with "./a.out"
        *"./" = run
->The Components
    -.global _start = start at _start:
    -assembly coding consist of mnemonics (not case sensitive)
        *MOV R0, #65 = mov r0, #65
    -after running type "echo $?"  to print value in r0
    -@ = // = /* words *\
        *comments are ignored by the compiler
->Linking Files
    -ld = link dynamic
    -BAL = Branch ALways 
        *"BAL _name" at end of code
        *make a .global _name in 2nd file
        *start new code after part2: 
    -Assemble with 2 files
        *$as -o part1.o part1.s
        *$as -o part2.o part2.s
        *for ld file order does not matter
        *$ld -o a.out part1.o part2.o  //tethered
->Tidying Up
    -rm = remove file
        *only need .s file
    -mkdir = make file
    -cd file = go into file 
    -cd = root 
-------------------------------------------------------------------------
CH.4 ~ Bits of RISC Machine
->converting bases 
-------------------------------------------------------------------------
CH.5 ~ ARM Arrangements 
->Word Lengths
    -8  bits = 1 byte
    -32 bits = 4 byte = word(rasberry pi) 
->Byte and Word Accessed Memory
    -addresses = hex number
    -word-aligned address = number inside is divisible by 4
        *must to store code in arm
->Registers
    -16 registers 
        *each can hold a word
        *locations in arm 
        *avoid using r15
    -registers are designed to hold adresses and values 
    -LDR = LoaD Register 
        *LDR R1, [R5] @ Load R1 with content from R5
    -STR = STore a Register
        *STR R1, [R6] @ Store whats inside R1 at R6
    -[] = adressing mode 
        *they have adresses
->Program Counter
    -PC = R15
    -keeps track of where program is in execution
->Current Program Status Register
    -Used to store result of operations 
    -N = negative flag
        *activates if the number is negative 
    -Z = zero flag
        *set if result is zero
    -C = carry flag
        *unsigned(non-negative) arithmetic operations
        *goes beyond scope 
    -V = Overflow flag
        *signed arithmetic
        *opperation goes above 32 bit 
->Bits and flags
    -BEQ = Branch if EQual
        *BEQ zeroset //jumps to label if zero flag is triggered
    -BNE = Branch if Not Equal
        *BNE zeroclear //jumps to label if zero flag is not triggered
        *often used to loop
->Setting flags
    -CMP <Operand1> <Operand2>
        *sub 2 from 1
        *pos, neg, or zero
        *Operand1 must be a register 
        *Operand2 can be a value 
        *Use with BEQ to branch
    -Normal operation like SUB dont trigger flags
->S Suffix 
    -add S at the end of operation to trigger flags 
        *SUBS or SUB S 

-------------------------------------------------------------------------
CH.6 ~ Data Processing
-><Instruction> <Dest> <Operand1> <Operand2>
->Addition Instructions
    -ADD
    -ADDS
        *Sets Flags/updates
    -ADC = ADd with Carry
        *Uses Flags 
    -adding two 64-bit numbers 
        *Result = R0 and R1
        *1st number = R2 and R3
        *2nd number = R4 and R5
        *lower register hold the lower half
    -example code: 
        *MOV R2, #0xFFFFFFFF @ low half number 1
        *MOV R3, #0x1 @ hi half number 1
        *MOV R4, #0xFFFFFFFF @ low half number 2
        *MOV R5, #0xFF @ hi half number 2
        *ADDS R0, R2, R4 @ add low and set flags
        *ADCS R1, R3, R5 @ add hi with carry
->Subtraction
    -SUB/SBC(consider flag)
        *SUB R0, R1, R2 // R0 = R1 - R2
    -RSB/SRC(consider flag)
        *RSB R0, R1, R2 // R0 = R2 - R1
    -C = 0 / A borrow generated  
    -C = 1 / borrow not generated 
    -SBC inverts carry flag
->Multiplication
    -MUL (<suffix>) <dest>, <Operand1>, <Operand2>
        *MUL R0, R1, R2 @ R0 = R1 * R2 
    -Dest can not be the same register as Operand1
    -Operands must be a register
    -MLA = MuLtiply with Accumulate.
        *MLA R0, R1, R2, R0 @ R0=(R1 * R2) + R0
        *sum can be the same as the destination register 
->Divide Arrives
    -SDIV - Signed DIVision
        *SDIV <dest>, <numerator>, <denominator>
    -UDIV - Unsigned DIVision
        *UDIV <dest>, <numerator>, <denominator>
    -no dest = asnwer goes to numerator 
->Move Instructions
    -MOV
        *MOV (<suffix>) <dest>, <Operand2>
        *creates a copy operand 2 register stays the same
        *MOVS to update status register
            >MOVS R0, #0 // sets a zero flag
    -MVN = MoVe Negative 
        *MVN (<suffix>) <dest>, <Operand2>
        *MVN R0, #9 @ Move -9 into R0
        *MVN R0, #0 @ set R0 to -1
        *MVN R1, #1 @ set R1 to -2
->Compare Instructions 
    -CMP <Operand1>, <Operand2> @ Set flags of <Op1>-<Op2>
        *CMP R3, #0 // zero flag if R3 = 0
        *CMP R3, #128 // zero flag if R3 = 128
        *if op1 < op2 = negative flag 
    -CMN <Operand1>, <Operand2> @ Set flags of <Op1>+<Op2>
        *Negative CMP 
        *CMN R0, #1 @ Compare R0 with -1
    -No S suffix
-------------------------------------------------------------------------
CH.7 ~ ROS Ins and Outs
->SWI and SVC Commands
    -SWI = SoftWare Interrupt
        *program is paused and a routine is done
        *sometimes called SVC (SuperVisor Call )
        * SWI 0 = SVC 0
    -Action is determined by number in r7
        *the first few registers are used as arguments
-> Writing to the Screen
    -syscall 4
    -R7 = the number of the Syscall, so R7=4
    -aruments
        *R0= the output stream, 1 for the monitor
        *R1= the address of the string of characters
        *R2= the number of characters to be written
    -example
        *MOV R7, #4 @ Syscall number
        *MOV R0, #1 @ Stdout is monitor
        *MOV R2, #19 @ string is 19 chars long // "\n" = 1 char
        *LDR R1,=string @ string located at string:
        *SWI 0
    -.data tells assembler code is a subsection with data
        *if placed at start use ".start" to show start of code
->Reading from the keyboard
    -syscall 3
    -arguments
        *R0= input stream, this is 0 for the
        *R1= buffer address for string of characters read to be placed
        *R2= the number of characters to be read
        *R7= the number of the Syscall, so R7=3
    -example code 
        *MOV R7, #3 @ Syscall number
        *MOV R0, #0 @ Stdin is keyboard
        *MOV R2, #5 @ read first 5 characters
        *LDR R1,=string @ string placed at string:
        *SWI 0
    -can also use .ascii "       " as a buffer for read
    -user can type unlimited numbers
        *only value from r2 will be read in 
        *anything else will be read in as a terminal command
        *return can be inputed if space is left 
->Eax and Others
    -a lot of syscall documentation is made for i386 not arm
    -"Make" = software to control generation of exe  
    -more info at: www.gnu.org/software/make/
-------------------------------------------------------------------------
CH.8 ~ Logical Operations
->Logical AND 
    -4 rules
        *0 AND 0 = 0 [Nought and nought is nought]
        *1 AND 0 = 0 [One and nought is nought]
        *0 AND 1 = 0 [Nought and one is nought]
        *1 AND 1 = 1 [One and one are one]br/>
    -Both must be activated to work 
    -used to turn off bits
->Logical OR
    -4 rules
        *0 OR 0 = 0 [Nought or nought is nought]
        *1 OR 0 = 1 [One or nought is one]
        *0 OR 1 = 1 [Nought or one is one]
        *1 OR 1 = 1 [One or one are one]
    -activates if 1 or more are present
    -used to turn on bits
->Logical EOR
    -4 rules, Exclusive ORoperation
        *0 EOR 0 = 0 [Nought exclusive or nought is nought]
        *1 EOR 0 = 1 [One exclusive or is one]
        *0 EOR 1 = 1 [Nought exclusive or one is one]
        *1 EOR 1 = 0 [One exclusive or one is nought]
    -activates if only one is on  
    -used to invert numbers with 111111111(same as MVN instruction)
->Logical Instructions
    -Commands:
        *AND (<suffix>) <dest>, <Operand1>, <Operand2>
        *ORR (<suffix>) <dest>, <Operand1>, <Operand2>
        *EOR (<suffix>) <dest>, <Operand1>, <Operand2>
    -Use suffix to set flags 
    -Operand1 must be a register 
    -Example code:
        *AND R0, R0, #1 @ preserve state of b0 in R0
        *ORR R1, R1, #2 @ ensure bit 1 in R1 is set
        *EOR R2, R2, #255 @ invert bits in low byte R2
->ORR to Convert Character Case
    -0x20 value difference between a/A, b/B, ...etc
    -use ORR to change example: 
        *LDR R1, =string @ address of char
        *LDR R0, [R1] @ load it into R0
        *ORR R0, R0, #0x20 @ change case
        *STR R0, [R1] @ write char back
->Bit Clear with BIC
    -clears individual bits in registers or mem locations
    -BIC (<suffix>) <dest>, <Operand1>, <Operand2>
    -Example code:\
        *BIC R0, R0, #%1111 @ clear low 4 bits of R0.
->Flag Test
    -TST = TeSt BiTs 
        *TST <Operand1>, <Operand2>
        *TST R0, #128 @ Test if b7 of R0 is set
        *logical AND
    -TEQ = Test EQuivalence
        *TEQ <Operand1>, <Operand2> 
        *TEQ R0, R1 @ Test if R0 & R1 are same
        *Uses EOR process
    -LSL = Logical Shift Left
    -example code:
        *MOV R10, #1: 00000000 00000000 00000000 00000001
        *LSL #31: 10000000 00000000 00000000 00000000
        *<< shift left by 31 places <<
    -ascii #'1' != value #1 
-------------------------------------------------------------------------
CH.9 ~ Condistional Execution 

-------------------------------------------------------------------------
CH.10 ~
-------------------------------------------------------------------------
CH.11 ~
-------------------------------------------------------------------------
CH.12 ~
-------------------------------------------------------------------------
CH.13 ~
-------------------------------------------------------------------------
CH.14 ~
-------------------------------------------------------------------------
CH.15 ~
-------------------------------------------------------------------------
CH.16 ~
-------------------------------------------------------------------------
CH.17 ~
-------------------------------------------------------------------------
CH.18 ~
-------------------------------------------------------------------------
CH.19 ~ 
-------------------------------------------------------------------------
CH.20 ~
-------------------------------------------------------------------------
CH.21 ~
-------------------------------------------------------------------------
CH.22 ~ 
-------------------------------------------------------------------------
CH.23 ~
-------------------------------------------------------------------------
CH.24 ~ 
-------------------------------------------------------------------------
CH.25 ~ 
-------------------------------------------------------------------------
CH.26 ~
-------------------------------------------------------------------------
CH.27 ~
-------------------------------------------------------------------------
CH.28 ~
-------------------------------------------------------------------------
CH.29 ~
-------------------------------------------------------------------------
CH.30
-------------------------------------------------------------------------